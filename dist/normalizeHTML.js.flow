// @flow

import patchAnchorElements from './patchAnchorElements';
import patchBreakElements from './patchBreakElements';
import patchElementInlineStyles from './patchElementInlineStyles';
import patchListElements from './patchListElements';
import patchParagraphElements from './patchParagraphElements';
import patchStyleElements from './patchStyleElements';
import patchTableElements from './patchTableElements';

const CHAR_NO_BREAK_SPACE = '\u202F';

export default function normalizeHTML(html: string): string {
  let body: ?HTMLElement = null;

  const sourceIsPage = /<body[\s>]/i.test(html);

  // Provides a dom node that will not execute scripts
  // https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation.createHTMLDocument
  // https://developer.mozilla.org/en-US/Add-ons/Code_snippets/HTML_to_DOM
  if (
    typeof document !== 'undefined' &&
    document.implementation &&
    document.implementation.createHTMLDocument
  ) {
    html = html.
      replace(/&nbsp;/g, CHAR_NO_BREAK_SPACE).
      replace(/_+/g, (matched) => {
        // This is a workround to convert "_______" into none-wrapped text
        // that apppears like a horizontal line.
        if (matched && matched.length >= 20) {
          // needs extra space after it so user can escape the <nobr />.
          matched = `<nobr>${String(matched)}</nobr> `;
        }
        return matched;
      });

    const doc = document.implementation.createHTMLDocument('');
    doc.open();
    doc.write(html);
    doc.close();
    // styles.
    patchStyleElements(doc);
    patchElementInlineStyles(doc);
    // contents.
    patchAnchorElements(doc);
    patchBreakElements(doc);
    patchListElements(doc);
    patchParagraphElements(doc);
    patchTableElements(doc);
    body = doc.getElementsByTagName('body')[0];

    if (body && sourceIsPage) {
      // Source HTML contains <body />, assumes this to be a complete
      // page HTML. Assume this <body /> may contain the style that indicates
      // page's layout.
      const frag = doc.createElement('html');
      frag.appendChild(body);
      return frag.innerHTML;
    }
  }

  if (!body) {
    // <body /> should alway be generated by doc.
    return 'Unsupported HTML content';
  }

  // HTML snippet only.
  return '<body>' + body.innerHTML + '</body>';
}
