const invariant = require('invariant');
const querystring = require('querystring');
const url = require('url');

const EMPTY_DOC_JSON = {
  'type': 'doc',
  'content': [
    {
      'type': 'paragraph',
      'content': [
        {
          'type': 'text',
          'text': ' ',
        },
      ],
    },
  ],
};

function assertNumber(val, name) {
  invariant(
    typeof val === 'number' && !isNaN(val),
    name + '(' + String(val) + ') is not a number',
  );
}

function assertNotNull(val, name) {
  invariant(
    val !== null && val !== undefined,
    name + '(' + String(val) + ') is null',
  );
}

function assertObject(val, name) {
  invariant(
    typeof val === 'object' && val !== null,
    name + '(' + String(val) + ') is not an Object',
  );
}

function assertArray(val, name) {
  invariant(
    Array.isArray(val),
    name + '(' + String(val) + ') is not an Array',
  );
}

class DocServer {

  constructor() {
    this.requestCount = 0;
    this.startTime = Date.now();
    this.handleRequest = this.handleRequest.bind(this);
    this.handleGet = this.handleGet.bind(this);
    this.handlePost = this.handlePost.bind(this);
    this.log = this.log.bind(this);
  }

  handleRequest(request, response) {
    this.requestCount++;

    const parsed = url.parse(request.url, true);
    const path = parsed.pathname || '';
    const method = request.method;

    const payload = {
      path: path,
      method: method,
      server: {
        requestCount: this.requestCount,
        requestTime: Date.now(),
        startTime: this.startTime,
      },
    };

    // this.log('start');

    if (method.toUpperCase() === 'POST') {
      let body = '';
      request.on('data', function(chunk) {
        body += chunk.toString();
      });
      request.on('end', function() {
        const query = JSON.parse(querystring.parse(body).params);
        payload.params =  toParams(query.params);
        // this.log(JSON.stringify(payload));
        this.handlePost(request, response,  payload);
        // this.log('end');
        body = null;
      }.bind(this));
    } else {
      payload.params = toParams(parsed.query);
      // this.log(JSON.stringify(payload));
      this.handleGet(request, response,  payload);
      this.log(method + ' end');
    }
  }

  respond(response, payload) {
    response.writeHead(200, {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*',
    });
    const jsonString = JSON.stringify(payload, null, 2);
    response.end(jsonString);
  }

  respond404(response) {
    response.writeHead(404, {
      'Content-Type': 'application/',
      'Access-Control-Allow-Origin': '*',
    });
    const payload = {error: 'not found'};
    const jsonString = JSON.stringify(payload, null, 2);
    response.end(jsonString);
  }

  handleGet(request, response,  payload) {
    throw new Error('not supported');
  }

  handlePost(request, response,  payload) {
    const params = payload.params;
    const editorState = params.editorState;
    const docID = params.docID;
    const clientID = params.clientID;
    const steps = params.steps;
    const version = params.version;

    assertArray(steps, 'steps');
    assertNumber(docID, 'docID');
    assertNotNull(clientID , 'clientID');
    assertNumber(version, 'version');

    let docModel = DocModel.findBy((model) => {
      return model.id === docID;
    });

    if (!docModel) {
      // This should not happen in production. The DOC must be a valid object.
      this.log('create doc model for ' + docID);
      docModel = DocModel.create({
        id: docID,
        version: version,
        editor_state: EMPTY_DOC_JSON,
      });
      DocModel.insert(docModel);
    }

    assertNotNull(docModel, 'docModel');

    payload.comitted = false;

    let added = 0;
    steps.forEach(step => {
      assertNotNull(step.key, 'step.key');
      const stepKey = step.key;
      let stepModel = StepModel.findBy(s => s.key === stepKey);
      if (stepModel === null) {
        this.log('insert step ' + stepKey);
        const stepJSON = Object.assign({}, step, {
          client_id: clientID,
          doc_id: docID,
          key: stepKey,
          version: version,
        });
        stepModel = StepModel.create(stepJSON);
        StepModel.insert(stepModel);
        added++;
      }
    });


    if (version > docModel.version) {
      this.log('version from the future?');
      payload.steps = [];
      payload.marooned = true;
    } else if (version < docModel.version) {
      const diff = docModel.version - version;
      if (diff > 5000000) {
        this.log('version is too old. ' + diff + ' versions behind');
        payload.steps = [];
        payload.marooned = true;
      } else {
        this.log('version is behind ' + diff + ' versions');
        payload.steps = StepModel.where((model) => {
          return (
            model.version >= version &&
            model.clientID !== clientID
          );
        }).sort(sortSteps);
      }
    } else {
      if (added) {
        this.log('added ' + added + ' steps');
        docModel.update({
          editor_state: editorState,
          version: version,
        });
      }
      payload.steps = StepModel.where((model) => {
        return (
          model.version === version// &&
          //model.clientID !== clientID
        );
      }).sort(sortSteps);
      this.log('version ' + version + ' has ' + payload.steps.length + ' steps');
    }
    payload.editorState = docModel.editor_state;
    payload.docID = docModel.id;
    payload.version = docModel.version;
    payload.marooned = !!payload.marooned;
    this.respond(response, payload);
  }

  log(msg) {
    console.log('==========================================================\n');
    console.log(msg);
    console.log('----------------------------------------------------------\n');
  }
};

function createModelClass(spec) {
  assertObject(spec, 'model.spec');

  const models = [];
  let index = 0;

  class Model {
    constructor(payload) {
      this.created_at = Date.now();
      this.updated_at = Date.now();
      this.update = this.update.bind(this);
      this.validate = this.validate.bind(this);
      payload && Object.assign(this, payload);
      this.validate();
    }

    validate() {
      Object.keys(spec).forEach(key => {
        assertNotNull(spec[key], key);
      });
    }

    update(payload) {
      payload && Object.assign(this, payload);
      this.updated_at = Date.now();
      this.validate();
    }

    toJSON() {
      const model = this;
      const json = {};
      Object.keys(spec).forEach(key => {
        json[key] = model[key];
      });
      return json;
    }
  }

  Model.size = 0;

  Model.findBy = (predict) => {
    let found = null;
    models.some((model) => {
      if (predict(model)) {
        found = model;
      }
    });
    return found;
  };

  Model.where = (predict) => {
    return models.reduce((results, model) => {
      if (predict(model)) {
        results.push(model);
      }
      return results;
    }, []);
  };

  Model.insert = (model) => {
    const id = model.id;
    assertNotNull(id, 'model.id');
    const predict = (m) => m.id === id;
    invariant(Model.findBy(predict) === null, 'duplicated model ' + id);
    models.push(model);
    Model.size = models.length;
    return model;
  };

  Model.create = (payload) => {
    payload = payload || {};
    payload.id = payload.id || index++;
    const model = new Model(payload);
    return model;
  };

  return Model;
}

const DocModel = createModelClass({
  id: '',
  version: 0,
  editor_state: {},
});

const StepModel = createModelClass({
  client_id: '',
  data: {},
  doc_id: 0,
  id: 0,
  key: '',
  version: 0,
});

function sortSteps(a, b) {
  if (a.id > b.id) {
    return 1;
  }
  if (a.id < b.id) {
    return  -1;
  }
  return 0;
}

function toParams(params) {
  Object.keys(params).forEach(key => {
    if (key === 'docID' || key === 'version') {
      params[key] = parseInt(params[key], 10);
    }
  });
  return params;
}

module.exports = DocServer;